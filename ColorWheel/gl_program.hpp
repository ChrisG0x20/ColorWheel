//  Copyright (c) 2016 Christopher Gassib. All rights reserved.
//

#ifndef PROGRAM_H
#define PROGRAM_H

#include <string>
#include <opengl/gl3.h>
#include <glm/glm.hpp>
#include "gl_exceptions.hpp"
#include "gl_info_log.inl"
#include "gl_get_uniform.hpp"
#include "gl_set_uniform.hpp"


namespace gl { namespace impl
{

    // Throws:  InvalidValue : programName or shader is bad
    //          InvalidOperation : programName or shader is bad;
    //                             or, shader is already attached to program
    inline void Attach(const GLuint programName, const Shader& shader)
    {
        ::glAttachShader(programName, shader.Name());
        VerifyNoErrors();
    }

    // Throws:  InvalidValue : programName is bad;
    //                         or, index >= GL_MAX_VERTEX_ATTRIBS
    //          InvalidOperation : programName is bad;
    //                             or, variableName uses a reserved prefix
    inline void BindAttribute(
                              const GLuint programName,
                              const GLuint index,
                              const std::string& variableName
                              )
    {
        ::glBindAttribLocation(programName, index, variableName.c_str());
        VerifyNoErrors();
    }

    // Throws:  InvalidValue : programName is bad
    //          InvalidOperation : programName is bad;
    //                             or, name is the currently active program object and transform
    //                                 feedback mode is active
    inline void Link(const GLuint programName)
    {
        ::glLinkProgram(programName);
        VerifyNoErrors();
    }

    // Returns: true if the last link attempt was successful.
    // Throws:  InvalidValue : programName is bad
    //          InvalidOperation : programName is bad
    inline bool IsLinked(const GLuint programName)
    {
        GLint result = GL_FALSE;

        ::glGetProgramiv(programName, GL_LINK_STATUS, &result);
        VerifyNoErrors(); // Any other exception types indicate a programming error.

        return GL_TRUE == result;
    }

    // Causes the OpenGL driver to validate the current shader program.
    // Throws:  InvalidValue : programName is bad
    //          InvalidOperation : programName is bad
    inline void Validate(const GLuint programName)
    {
        ::glValidateProgram(programName);
        VerifyNoErrors();
    }

    // Returns: true, if the program was validated successfully.
    // Throws:  InvalidValue : programName is bad
    //          InvalidOperation : programName is bad
    inline bool IsValidProgram(const GLuint programName)
    {
        GLint result = GL_FALSE;

        ::glGetProgramiv(programName, GL_VALIDATE_STATUS, &result);
        VerifyNoErrors(); // Any other exception types indicate a programming error.

        return GL_TRUE == result;
    }

    // Add this program to the currently active set of running shader programs.
    // Throws:  InvalidValue : programName is neither 0 nor a value generated by OpenGL
    //          InvalidOperation : programName is bad;
    //                             or, the program could not be made part of current state;
    //                             or, transform feedback mode is active
    inline void Use(const GLuint programName)
    {
        ::glUseProgram(programName);
        VerifyNoErrors();
    }

    // Returns: The location of a uniform variable, or -1 if not found.
    // Throws:  InvalidValue : programName is bad
    //          InvalidOperation : programName is bad;
    //                             or, the program hasn't been linked yet
    inline GLint GetUniformLocation(const GLuint programName, const std::string& uniformName)
    {
        const auto result = ::glGetUniformLocation(programName, uniformName.c_str());
        VerifyNoErrors();
        return result;
    }

    // Returns: The number of active uniforms associated with the specified shader program.
    // Throws:  InvalidValue : programName is bad
    //          InvalidOperation : programName is bad
    inline GLint GetActiveUniformCount(const GLuint programName)
    {
        GLint result = 0;
        ::glGetProgramiv(programName, GL_ACTIVE_UNIFORMS, &result);
        VerifyNoErrors(); // Any other exception types indicate a programming error.
        return result;
    }
    
    // Returns: The maximum buffer size required to read any active uniform variable name (including
    //              null-terminator; or, 0 if there are no active uniform variables.
    // Throws:  InvalidValue : programName is bad
    //          InvalidOperation : programName is bad
    inline GLint GetUniformMaxLength(const GLuint programName)
    {
        GLint result = 0;
        ::glGetProgramiv(programName, GL_ACTIVE_UNIFORM_MAX_LENGTH, &result);
        VerifyNoErrors(); // Any other exception types indicate a programming error.
        return result;
    }

    // Arguments: uniformIndex : legal values are from 0 to GetActiveUniformCount() - 1
    // Returns: The name of the active uniform located at the specified index; or, an empty string.
    //              If one or more elements of an array are active, the name of the array is
    //              returned.
    //          size : Returns the highest array element index used, plus one, as determined by the
    //              compiler and/or linker.
    //          type : The GL type of the uniform: GL_FLOAT, GL_FLOAT_VEC2, etc...
    //              (see: official glGetActiveUniform docs for a complete list)
    // Throws:  InvalidValue : programName is bad;
    //                         or, uniformIndex is greater than or equal to the number of active
    //                             uniform variables in program.
    //          InvalidOperation : programName is bad
    //          std::bad_alloc
    inline std::string GetActiveUniform(
                                        const GLuint    programName,
                                        const GLuint    uniformIndex,
                                        GLint&          size,
                                        GLenum&         type
                                        )
    {
        std::vector<GLchar> nameBuffer;
        {
            const auto RequiredBufferSize = GetUniformMaxLength(programName);

            if (0 == RequiredBufferSize)
            {
                return "";
            }

            nameBuffer.resize(RequiredBufferSize);
        }

        GLsizei length = 0;
        {
            ::glGetActiveUniform(
                                 programName,
                                 uniformIndex,
                                 static_cast<GLsizei>(nameBuffer.size()),
                                 &length,
                                 &size,
                                 &type,
                                 &nameBuffer[0]
                                 );
            VerifyNoErrors();
        }

        return std::string(&nameBuffer[0], std::min(static_cast<size_t>(length), nameBuffer.size()));
    }

    inline std::string CopyProgramInfoLog(const GLuint programName)
    {
        return detail::CopyGlInfoLog(programName, &::glGetProgramiv, &::glGetProgramInfoLog);
    }

} // namespace impl


    class Program
    {
    public:
        Program()
        {
            _programName = ::glCreateProgram();
            if (0 != _programName)
            {
                return;
            }

            // NOTE: The GL documentation doesn't specify any specific error codes in the event of a
            // failure; only that program creation can fail.
            VerifyNoErrors();
            throw std::runtime_error("failed to create shader program resource");
        }

        virtual ~Program()
        {
            ::glDeleteProgram(_programName);
            AssertNoErrors();
        }

        // Get the native OpenGL name of this program resource.
        GLuint Name() const noexcept
        {
            return _programName;
        }

        // Throws: InvalidOperation : shader is already attached to program
        void Attach(const Shader& shader)
        {
            // NOTE: Any other exception would indicate a programming error.
            impl::Attach(_programName, shader);
        }

        // Binds a vector index to a vertex shader input variable.
        // Each attribute consists of one 4-element vector value, which can be a floating-point
        // value, signed integral, unsigned integral, or (in GL 4.1+) a double-precision float.
        // A typical layout for a vertex might be:
        //
        // typedef vec4 vertex_layout_t[NUM_ATTRIBUTES];
        //
        // vertex_layout_t vertices[MAX_VERTICES];
        //
        // for (auto i = 0; i < MAX_VERTICES; ++i)
        // {
        //     vertex_layout_t& vertex = vertices[i];
        //
        //     vertex[0] = { x, y, z, 1.0f } // vertex
        //     vertex[1] = ...
        //     vertex[2] = { x, y, z, 1.0f } // normal
        //     vertex[3] = { r, g, b, 1.0f } // color
        //     vertex[4] = { r, g, b, 1.0f } // secondary-color
        //     vertex[5] = { x, y, z, 1.0f } // fog-coordinate
        //     vertex[6] = ...
        //     vertex[7] = ...
        //     vertex[8] = { r, s, t, 1.0f } // multi-texture-coordinate-0
        // }
        //
        // Throws:  InvalidValue : index >= GL_MAX_VERTEX_ATTRIBS
        //          InvalidOperation : variableName uses the reserved prefix "gl_"
        void BindVectorIndexToShaderInputVariable(
            const GLuint vectorIndex,
            const std::string& variableName
            )
        {
            impl::BindAttribute(_programName, vectorIndex, variableName);
        }

        // Link all the attached compiled shaders and bound variables.
        // Throws: InvalidOperation : this is the currently active program object and transform
        //                            feedback mode is active
        void Link()
        {
            impl::Link(_programName);
        }

        // Returns: true if the last link attempt was successful.
        bool IsLinked() const noexcept
        {
            return impl::IsLinked(_programName);
        }

        // Gets log information written by the driver as part of the link phase.
        // Throws: std::bad_alloc
        std::string GetLinkerOrValidationOutput() const
        {
            return impl::CopyProgramInfoLog(_programName);
        }

        // Add this program to the currently active set of running shader programs.
        // Throws: InvalidOperation : the program could not be made part of current state;
        //                            or, transform feedback mode is active
        void Use()
        {
            impl::Use(_programName);
        }

        // Causes the OpenGL driver to validate the current shader program.
        void Validate() noexcept
        {
            impl::Validate(_programName);
        }

        // Returns: true, if the program was validated successfully.
        bool IsValid() const noexcept
        {
            return impl::IsValidProgram(_programName);
        }

        // Returns: The number of active uniforms associated with this shader program.
        GLint GetActiveUniformCount() const noexcept
        {
            return impl::GetActiveUniformCount(_programName);
        }

        // Used to get the name, size, and type of a uniform via its OpenGL assigned index.
        // Arguments: uniformIndex : legal values are from 0 to GetActiveUniformCount() - 1
        // Returns: The name of the active uniform located at the specified index; or, an empty
        //              string. If one or more elements of an array are active, the name of the
        //              array is returned.
        //          size : Returns the highest array element index used, plus one, as determined by
        //              the compiler and/or linker.
        //          type : Returns the GL type of the uniform: GL_FLOAT, GL_FLOAT_VEC2, etc...
        //              (see: official glGetActiveUniform docs for a complete list)
        // Throws:  InvalidValue : uniformIndex is greater than or equal to the number of active
        //                             uniform variables in program.
        //          std::bad_alloc
        std::string GetActiveUniform(const GLuint uniformIndex, GLint& size, GLenum& type) const
        {
            return impl::GetActiveUniform(_programName, uniformIndex, size, type);
        }

        // Used to find the OpenGL assigned index of uniform via its name.
        // Returns: The location of a uniform variable, or -1 if not found.
        // Throws: InvalidOperation : the program hasn't been linked yet
        GLint GetUniformLocation(const std::string& uniformName) const
        {
            return impl::GetUniformLocation(_programName, uniformName);
        }

        // Gets the current value of a uniform via its OpenGL assigned index.
        // Returns: the requested uniform variable
        // Throws: InvalidOperation : uniformLocation is bad;
        //                            or, the program hasn't been linked
        template<typename uniform_t>
        uniform_t GetUniform(const GLint uniformLocation) const
        {
            const auto result = impl::GetProgramUniform<uniform_t>(_programName, uniformLocation);
            VerifyNoErrors();
            return result;
        }

        // Set a uniform scalar, glm::vec<>, glm::mat<>, C-array, std::array<>, or std::vector<>.
        // Throws:  InvalidOperation : there is no current program object;
        //              or, the size of the uniform variable declared in the shader does not match
        //                  the size indicated by the passed uniform type;
        //              or, an integer variant of these functions was used to load a uniform
        //                  variable of a floating-point type;
        //              or, a floating-point variant of these functions was used to load a uniform
        //                  variable of an interger type;
        //              or, a signed interger varient of these functions was used to load an
        //                  unsigned uniform variable;
        //              or, an unsigned interger varient of these functions was used to load a
        //                  signed uniform variable;
        //              or, location is an invalid uniform location for the current program object
        //                  and location is not equal to -1;
        //              or, a sampler is loaded using a command other than a single GLint or an
        //                  array of GLints
        template<typename uniform_t>
        void SetUniform(const GLint uniformLocation, const uniform_t& v) const
        {
            impl::SetUniform(uniformLocation, v);
            VerifyNoErrors();
        }

        // Set a buffer of uniform scalars, glm::vec<>, or glm::mat<>.
        // Throws:  InvalidOperation : there is no current program object;
        //              or, the size of the uniform variable declared in the shader does not match
        //                  the size indicated by the passed uniform type;
        //              or, an integer variant of these functions was used to load a uniform
        //                  variable of a floating-point type;
        //              or, a floating-point variant of these functions was used to load a uniform
        //                  variable of an interger type;
        //              or, a signed interger varient of these functions was used to load an
        //                  unsigned uniform variable;
        //              or, an unsigned interger varient of these functions was used to load a
        //                  signed uniform variable;
        //              or, location is an invalid uniform location for the current program object
        //                  and location is not equal to -1;
        //              or, a sampler is loaded using a command other than a single GLint or an
        //                  array of GLints
        //          InvalidValue : buffer count is less than 0
        template<typename uniform_t>
        void SetUniform(
                        const GLint uniformLocation,
                        const uniform_t* const a,
                        const GLsizei count
                        ) const
        {
            impl::SetUniform(uniformLocation, a, count);
            VerifyNoErrors();
        }

        // Set a two scalar uniform.
        // Throws:  InvalidOperation : there is no current program object;
        //              or, the size of the uniform variable declared in the shader does not match
        //                  the size indicated by the passed uniform type;
        //              or, an integer variant of these functions was used to load a uniform
        //                  variable of a floating-point type;
        //              or, a floating-point variant of these functions was used to load a uniform
        //                  variable of an interger type;
        //              or, a signed interger varient of these functions was used to load an
        //                  unsigned uniform variable;
        //              or, an unsigned interger varient of these functions was used to load a
        //                  signed uniform variable;
        //              or, location is an invalid uniform location for the current program object
        //                  and location is not equal to -1;
        //              or, a sampler is loaded using a command other than a single GLint or an
        //                  array of GLints
        template<typename uniform_t>
        void SetUniform(const GLint uniformLocation, const uniform_t v0, const uniform_t v1) const
        {
            impl::SetUniform(uniformLocation, v0, v1);
            VerifyNoErrors();
        }

        // Set a three scalar uniform.
        // Throws:  InvalidOperation : there is no current program object;
        //              or, the size of the uniform variable declared in the shader does not match
        //                  the size indicated by the passed uniform type;
        //              or, an integer variant of these functions was used to load a uniform
        //                  variable of a floating-point type;
        //              or, a floating-point variant of these functions was used to load a uniform
        //                  variable of an interger type;
        //              or, a signed interger varient of these functions was used to load an
        //                  unsigned uniform variable;
        //              or, an unsigned interger varient of these functions was used to load a
        //                  signed uniform variable;
        //              or, location is an invalid uniform location for the current program object
        //                  and location is not equal to -1;
        //              or, a sampler is loaded using a command other than a single GLint or an
        //                  array of GLints
        //              or, attempted to load a sampler with this overload
        template<typename uniform_t>
        void SetUniform(
                        const GLint uniformLocation,
                        const uniform_t v0,
                        const uniform_t v1,
                        const uniform_t v2
                        ) const
        {
            impl::SetUniform(uniformLocation, v0, v1, v2);
            VerifyNoErrors();
        }

        // Set a four scalar uniform.
        // Throws:  InvalidOperation : there is no current program object;
        //              or, the size of the uniform variable declared in the shader does not match
        //                  the size indicated by the passed uniform type;
        //              or, an integer variant of these functions was used to load a uniform
        //                  variable of a floating-point type;
        //              or, a floating-point variant of these functions was used to load a uniform
        //                  variable of an interger type;
        //              or, a signed interger varient of these functions was used to load an
        //                  unsigned uniform variable;
        //              or, an unsigned interger varient of these functions was used to load a
        //                  signed uniform variable;
        //              or, location is an invalid uniform location for the current program object
        //                  and location is not equal to -1;
        //              or, a sampler is loaded using a command other than a single GLint or an
        //                  array of GLints
        //              or, attempted to load a sampler with this overload
        template<typename uniform_t>
        void SetUniform(
                        const GLint uniformLocation,
                        const uniform_t v0,
                        const uniform_t v1,
                        const uniform_t v2,
                        const uniform_t v3
                        ) const
        {
            impl::SetUniform(uniformLocation, v0, v1, v2, v3);
            VerifyNoErrors();
        }

        Program(const Program&) = delete;
        Program& operator =(const Program&) = delete;

    private:
        GLuint _programName;

    //    void test()
    //    {
    //        SetUniform(0, 0.0f);
    //        SetUniform(0, 0.0f, 1.0f);
    //        SetUniform(0, glm::vec2());
    //        SetUniform(0, glm::mat2());
    //        SetUniform(0, std::vector<GLfloat>());
    //        SetUniform(0, std::array<GLfloat, 2>());
    //        SetUniform(0, std::vector<glm::vec2>());
    //        SetUniform(0, std::array<glm::vec2, 2>());
    //        const GLfloat af[] = { 0.0f, 1.0f };
    //        SetUniform(0, af);
    //        SetUniform(0, af, sizeof(af) / sizeof(af[0]));
    //        const glm::vec2 av[] = { glm::vec2(), glm::vec2() };
    //        SetUniform(0, av);
    //        SetUniform(0, av, sizeof(av) / sizeof(av[0]));
    //    }
    };

} // namespace gl


#endif
